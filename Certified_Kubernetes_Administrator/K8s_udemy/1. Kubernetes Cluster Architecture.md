# Welcome to the Kubernetes Cluster Architecture Lecture

Hello and welcome to this lecture.

## Overview

We start with a basic overview of the **Kubernetes cluster architecture**.

1. First, we look at the architecture at a high level.
2. Then we drill down into each of the components.
3. We explore their roles and responsibilities and how they are configured.
4. Finally, we go through a **practice test** where you will examine an existing cluster and identify various details related to its components.

---

## Understanding Kubernetes Through a Ship Analogy

We're going to use an **analogy of ships** to understand Kubernetes architecture.

### Purpose of Kubernetes

The purpose of Kubernetes is to host applications in the form of **containers** in an automated fashion:

- Easily deploy many instances of your application
- Enable communication between services

Many components work together to make this possible.

---

## 10,000-Foot View of Kubernetes Architecture

In our ship analogy, we have:

- **Cargo ships** = Worker nodes (do the actual work, carry containers)
- **Control ships** = Master node (manage the cargo ships)

---

## Kubernetes Cluster Components

### 1. Nodes

- A **Kubernetes cluster** consists of a set of **nodes** (physical or virtual, on-premise or cloud).
- These host applications as containers.

### 2. Master Node

The **master node** is like the **control ship**:

- Manages the cluster
- Stores node information
- Plans container placement
- Monitors the cluster

Uses a set of components called the **Control Plane Components**.

---

## Control Plane Components

### etcd

- A **highly available key-value store**
- Stores:
  - Node information
  - Container state
  - Cluster configuration
- Analogy: Logbooks or records of containers on ships

---

### Scheduler

- Like the **crane** that places containers on ships
- Determines:
  - Best node based on resource requirements
  - Capacity and constraints (e.g., taints, tolerations, node affinity)

---

### Controllers

- Like different **offices** at the dock handling special tasks:
  - **Node Controller**: Manages node availability
  - **Replication Controller**: Ensures desired number of containers are running

Other types of controllers also exist for various functions.

---

### Kube API Server

The **primary management component**:

- Orchestrates all operations
- Exposes the Kubernetes API
- Used by:
  - External users
  - Controllers
  - Worker nodes

---

## Container Runtime

Since everything in Kubernetes runs as containers, we need a **container runtime engine**:

- Common options:
  - Docker
  - containerd
  - CRI-O

Must be installed on all nodes, including master if you wish to host components as containers.

---

## Worker Nodes

Now, let’s focus on the **cargo ships** — the worker nodes.

### Kubelet

Each ship has a **captain** — that's the **kubelet**:

- An agent that runs on each node
- Listens to instructions from the Kube API Server
- Deploys or destroys containers
- Reports status of nodes and containers

---

### Kube Proxy

- Enables **network communication** between containers across nodes
- Ensures routing rules are in place for services to reach each other

Example: A web server in one container needs to reach a database in another container on a different node.

---

## Summary

### On the **Master Node**:
- `etcd`: Stores cluster state
- `kube-scheduler`: Places containers on nodes
- `controllers`: Manage specific functions
- `kube-apiserver`: Orchestrates operations

### On the **Worker Node**:
- `kubelet`: Manages containers
- `kube-proxy`: Enables service communication

---

## Next Steps

That’s a **high-level overview** of the Kubernetes architecture and its components.  
We will **drill down** into each of these in upcoming lectures.

**Thank you, and see you in the next lecture.**
